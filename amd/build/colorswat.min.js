define("tiny_bfhfontcolor/colorswat",["exports","./polyfill","./options"],(function(_exports,pf,_options){function _getRequireWildcardCache(nodeInterop){if("function"!=typeof WeakMap)return null;var cacheBabelInterop=new WeakMap,cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop)}Object.defineProperty(_exports,"__esModule",{value:!0}),_exports.registerTextColorButton=_exports.register$c=void 0,pf=function(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule)return obj;if(null===obj||"object"!=typeof obj&&"function"!=typeof obj)return{default:obj};var cache=_getRequireWildcardCache(nodeInterop);if(cache&&cache.has(obj))return cache.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj)if("default"!==key&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,desc):newObj[key]=obj[key]}newObj.default=obj,cache&&cache.set(obj,newObj);return newObj}
/**
   * Color palette setter for BFH Fontcolor plugin.
   * This code is mostly reused from the TinyMCE silver theme. However, this
   * code is enhanced to have two different color maps for background and
   * text color. Also, the option to enable or disable custom colors
   * via a colorpicker can be set independently on both text- and
   * background color. If the colorpicker is disabled and the color
   * map is empty for one of the text- or background color, the menu entry as
   * well as the toolbar button will not appear in the editor.
   *
   * @module      tiny_bfhfontcolor
   * @copyright   2023 Luca BÃ¶sch <luca.boesch@bfh.ch>
   * @copyright   2023 Stephan Robotta <stephan.robotta@bfh.ch>
   * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   */(pf);let global$4=localStorage;const Cell=initial=>{let value=initial;return{get:()=>value,set:v=>{value=v}}},storageName="tinymce-custom-colors",ColorCache=function(){let max=arguments.length>0&&void 0!==arguments[0]?arguments[0]:10,suffix=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";const storageString=global$4.getItem(storageName+suffix),localstorage=pf.isString(storageString)?JSON.parse(storageString):[],cache=max-(list=localstorage).length<0?list.slice(0,max):list;var list;const remove=idx=>{cache.splice(idx,1)};return{add:key=>{pf.indexOf(cache,key).each(remove),cache.unshift(key),cache.length>max&&cache.pop(),global$4.setItem(storageName,JSON.stringify(cache))},state:()=>cache.slice(0)}},colorCache=ColorCache(10),colorCacheBg=ColorCache(10,"-background"),getColorCols$1=(name="color_cols",editor=>editor.options.get(name));var name;const getColors$3=(editor,name)=>"bfh_forecolor"===name?(0,_options.getForecolorMap)(editor):(0,_options.getBackcolorMap)(editor),getCurrentColors=type=>((xs,f)=>{const len=xs.length,r=new Array(len);for(let i=0;i<len;i++){const x=xs[i];r[i]=f(x,i)}return r})("bfh_forecolor"===type?colorCache.state():colorCacheBg.state(),(color=>({type:"choiceitem",text:color,value:color}))),getCurrentColor=(editor,format)=>{let color;return editor.dom.getParents(editor.selection.getStart(),(elm=>{const value=(node=elm,pf.isNonNullable(node.style)?elm.style["bfh_forecolor"===format?"color":"backgroundColor"]:null);var node;value&&(color=color||value)})),pf.Optional.from(color)},applyColor=(editor,format,value,onChoice)=>{if("custom"===value){colorPickerDialog(editor)((colorOpt=>{colorOpt.each((color=>{(color=>{colorCache.add(color)})(color),editor.execCommand("mceApplyTextcolor",format,color),onChoice(color)}))}),"#000000")}else"remove"===value?(onChoice(""),editor.execCommand("mceRemoveTextcolor",format)):(onChoice(value),editor.execCommand("mceApplyTextcolor",format,value))},getFetch$1=(colors,hasCustom,type)=>callback=>{callback(((colors,hasCustom,type)=>colors.concat(getCurrentColors(type).concat((hasCustom=>{const remove={type:"choiceitem",text:"Remove color",icon:"color-swatch-remove-color",value:"remove"};return hasCustom?[remove,{type:"choiceitem",text:"Custom color",icon:"color-picker",value:"custom"}]:[remove]})(hasCustom))))(colors,hasCustom,type))},setIconColor=(splitButtonApi,name,newColor)=>{const id="bfh_forecolor"===name?"tox-icon-text-color__color":"tox-icon-highlight-bg-color__color";splitButtonApi.setIconFill(id,newColor)},registerTextColorButton=(editor,name,format,tooltip,lastColor)=>{let iconName,hasCustom;"bfh_forecolor"===name?(iconName="text-color",hasCustom=(0,_options.isForecolorPickerOn)(editor)):(iconName="highlight-bg-color",hasCustom=(0,_options.isBackcolorPickerOn)(editor)),editor.ui.registry.addSplitButton(name,{tooltip:tooltip,presets:"color",icon:iconName,select:value=>getCurrentColor(editor,format).bind((currentRgb=>pf.fromString(currentRgb).map((rgba=>{const currentHex=pf.fromRgba(rgba).value;return pf.contains$1(value.toLowerCase(),currentHex)})))).getOr(!1),columns:getColorCols$1(editor),fetch:getFetch$1(getColors$3(editor,name),hasCustom,name),onAction:()=>{applyColor(editor,format,lastColor.get(),pf.noop)},onItemAction:(_splitButtonApi,value)=>{applyColor(editor,format,value,(newColor=>{lastColor.set(newColor),((editor,data)=>{editor.dispatch("TextColorChange",data)})(editor,{name:name,color:newColor})}))},onSetup:splitButtonApi=>{setIconColor(splitButtonApi,name,lastColor.get());const handler=e=>{e.name===name&&setIconColor(splitButtonApi,e.name,e.color)};return editor.on("TextColorChange",handler),()=>{editor.off("TextColorChange",handler)}}})};_exports.registerTextColorButton=registerTextColorButton;const registerTextColorMenuItem=(editor,name,format,text)=>{editor.ui.registry.addNestedMenuItem(name,{text:text,icon:"bfh_forecolor"===name?"text-color":"highlight-bg-color",getSubmenuItems:()=>[{type:"fancymenuitem",fancytype:"colorswatch",initData:{allowCustomColors:"bfh_forecolor"===name?(0,_options.isForecolorPickerOn)(editor):(0,_options.isBackcolorPickerOn)(editor),colors:getColors$3(editor,name)},onAction:data=>{applyColor(editor,format,data.value,pf.noop)}}]})},colorPickerDialog=editor=>(callback,value)=>{let isValid=!1;const initialData={colorpicker:value};editor.windowManager.open({title:"Color Picker",size:"normal",body:{type:"panel",items:[{type:"colorpicker",name:"colorpicker",label:"Color"}]},buttons:[{type:"cancel",name:"cancel",text:"Cancel"},{type:"submit",name:"save",text:"Save",primary:!0}],initialData:initialData,onAction:(_api,details)=>{"hex-valid"===details.name&&(isValid=details.value)},onSubmit:api=>{const hex=api.getData().colorpicker;isValid?(callback(pf.Optional.from(hex)),api.close()):editor.windowManager.alert(editor.translate(["Invalid hex color code: {0}",hex]))},onClose:pf.noop,onCancel:()=>{callback(pf.Optional.none())}})};_exports.register$c=editor=>{if((0,_options.isForecolorPickerOn)(editor)||(0,_options.isBackcolorPickerOn)(editor)||0!==(0,_options.getForecolorMap)(editor).length||0!==(0,_options.getBackcolorMap)(editor).length){if((editor=>{editor.addCommand("mceApplyTextcolor",((format,value)=>{((editor,format,value)=>{editor.undoManager.transact((()=>{editor.focus(),editor.formatter.apply(format,{value:value}),editor.nodeChanged()}))})(editor,format,value)})),editor.addCommand("mceRemoveTextcolor",(format=>{((editor,format)=>{editor.undoManager.transact((()=>{editor.focus(),editor.formatter.remove(format,{value:null},void 0,!0),editor.nodeChanged()}))})(editor,format)}))})(editor),(0,_options.isForecolorPickerOn)(editor)||(0,_options.getForecolorMap)(editor).length>0){const lastForeColor=Cell("#000000");registerTextColorButton(editor,"bfh_forecolor","forecolor","Text color",lastForeColor),registerTextColorMenuItem(editor,"bfh_forecolor","forecolor","Text color")}if((0,_options.isBackcolorPickerOn)(editor)||(0,_options.getBackcolorMap)(editor).length>0){const lastBackColor=Cell("#000000");registerTextColorButton(editor,"bfh_backcolor","hilitecolor","Background color",lastBackColor),registerTextColorMenuItem(editor,"bfh_backcolor","hilitecolor","Background color")}}}}));

//# sourceMappingURL=colorswat.min.js.map